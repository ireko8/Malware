from pathlib import Path
from pprint import pformat
import lightgbm
import numpy as np
import pandas as pd
from sklearn.model_selection import StratifiedKFold
from config import conf
from utils import load_fs, now, plot_importance
from utils import make_submission, copy_script, rank_average
from tqdm import tqdm
from logger import Logger


def main():
    experiment_name = now()
    cv_path = Path(f'result/{experiment_name}')
    cv_path.mkdir(parents=True)

    copy_script(cv_path)
    log = Logger(experiment_name, cv_path / 'exp.log')

    log.info('load data')
    with log.interval_timer('load data'):
        train_df = load_fs()
        # train_df = load_fs()
        test = load_fs(test=True)
        train_df['is_test'] = False
        test['is_test'] = True
        test['HasDetections'] = -1
        df = pd.concat([train_df, test])
        for c, t in conf.dtypes.items():
            try:
                df[c] = df[c].astype(t)
            except KeyError:
                continue
        # df = df.loc[:, ~df.columns.str.contains('mean')]
        # df = df.loc[:, ~df.columns.str.contains('le')]
        # df = df.loc[:, ~df.columns.str.contains('nunique')]
        # df = df.loc[:, ~df.columns.str.contains('var')]
        # df = df.loc[:, ~df.columns.str.contains('count')]
        # df = df.loc[:, ~df.columns.str.contains('entropy')]
        # df = df.loc[:, ~df.columns.str.contains("_4")]

    log.info(pformat(list(df.columns)))
    for c in df.columns:
        for x in ['EngineVersion', 'AppVersion', 'AvSigVersion',
                  'Census_OSVersion', 'OsBuildLab']:
            if x in c:
                try:
                    df[c] = df[c].astype('int')
                except ValueError:
                    df[c] = df[c].astype('category')
    
    train_df = df.loc[~df.is_test].drop(['is_test'], axis=1)
    train_df = train_df.reset_index(drop=True)
    test = df.loc[df.is_test].drop(['HasDetections', 'is_test'], axis=1)
    test = test.reset_index(drop=True)

    # train_df = train_df.sort_values('AvSigVersion')
    # ver = train_df[["AvSigVersion_0", 
    #                 "AvSigVersion_1", 
    #                 "AvSigVersion_2"]].sort_values(by=["AvSigVersion_0", 
    #                                                    "AvSigVersion_1", 
    #                                                    "AvSigVersion_2"])
    # val_ind = ver.query("(AvSigVersion_1 >= 50) & (AvSigVersion_0 >= 1) & (AvSigVersion_2 >= 2000)").index
    train_df = train_df.drop([c for c in train_df.columns if 'AvSigVersion' in c], axis=1)
    test = test.drop([c for c in test.columns if 'AvSigVersion' in c], axis=1)
    # train = train_df[~train_df.index.isin(val_ind)]
    # val = train_df.loc[val_ind]
    # del df, train_df

    train = train_df
    train_X = train.loc[:, train.columns != 'HasDetections']
    train_y = train.loc[:, 'HasDetections']
    # val_X = val.loc[:, train.columns != 'HasDetections']
    # val_y = val.loc[:, 'HasDetections']
    train_set = lightgbm.Dataset(train_X, label=train_y)
    # val_set = lightgbm.Dataset(val_X, label=val_y)
    cv = StratifiedKFold(n_splits=5, random_state=conf.seed)

    log.info('learning start')
    log.double_kiritori()
    # model = lightgbm.train(conf.params, train_set,
    #                        num_boost_round=conf.num_boost_round,
    #                        valid_sets=val_set,
    #                        verbose_eval=conf.verbose_eval)
    model, res = lightgbm.cv(conf.params, train_set,
                           num_boost_round=conf.num_boost_round,
                           folds=cv,
                           verbose_eval=conf.verbose_eval)
    log.info(max(res['auc-mean']))
    log.info(len(res['auc-mean']))
    log.double_kiritori()
    log.info('done')

    # val_preds = model.predict(val_X)
    # np.save(cv_path / 'val_preds.npy', val_preds)

    fi_gain = model.feature_importance(importance_type='gain')
    fn = train_set.feature_name
    plot_importance(fi_gain, fn, cv_path)

    # del train, train_set, train_X, train_y, val_X, val_y

    preds = model.predict(test)
    test_preds = rank_average(preds)
    np.save(cv_path / 'test_preds.npy', test_preds)
    
    make_submission(test_preds, f'submissions/{experiment_name}.csv.gz')


if __name__ == '__main__':
    main()
